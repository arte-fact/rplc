#[macro_use]
extern crate lazy_static;

pub mod classic;

mod libs;

use std::io::{stdout, Error};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Duration;

use chrono::Local;
use clap::Parser;
use crossterm::event::{poll, read, Event, KeyCode, KeyEventKind, KeyModifiers};
use crossterm::execute;
use crossterm::style::Stylize;

use crossterm::terminal::{
    disable_raw_mode, enable_raw_mode, Clear, ClearType, EnterAlternateScreen,
};

use self::classic::classic_mode;
use self::libs::file_tree::{display_files_tree, sorted_paths_from_tree, tree_from_path_vec};
use self::libs::files::{list_glob_files, store_glob_files};
use self::libs::split_query::{split_query, QuerySplit};
use self::libs::state::{get_file, get_files_names, get_key_value, store_key_value};
use self::libs::terminal::{
    get_screen_size, hide_cursor, print_at, screen_height, screen_width, set_screen_size,
};
use self::libs::ui::window::{create_and_store_window, get_window, store_window, WindowAttr};

static FILE_COUNT: AtomicUsize = AtomicUsize::new(0);
static REPLACED_COUNT: AtomicUsize = AtomicUsize::new(0);
static TOTAL_LINES: AtomicUsize = AtomicUsize::new(0);
static SCROLL_OFFSET: AtomicUsize = AtomicUsize::new(0);

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Opts {
    #[arg(help = "Glob pattern to search for files")]
    glob: Option<String>,

    #[arg(help = "Query to search for")]
    query: Option<String>,

    #[arg(help = "Substitute to replace query with")]
    substitute: Option<String>,

    #[arg(short, long, help = "Write changes to files")]
    write: bool,

    #[arg(short, long, help = "Classic mode")]
    classic: bool,
}

async fn handle_user_query_with_errors(user_query: &String) {
    match handle_user_query(&user_query).await {
        Ok(_) => (),
        Err(e) => debug!("Error: {}", e),
    }
}

fn print_help() -> Result<(), Error> {
    let help = format!(
        "Query format: {} {} {}",
        "<glob>".stylize().blue().bold(),
        "<query>".stylize().yellow().bold(),
        "<replacement>".stylize().green().bold()
    );
    print_at(0, 0, &help)?;
    let scroll_help = format!("↑/↓ to scroll, ESC to exit, CTRL+C to exit, ENTER to write changes");
    print_at(
        screen_width() as u16 - scroll_help.len() as u16,
        (screen_height() - 1) as u16,
        &scroll_help,
    )
}

async fn handle_search_and_replace(
    search: Option<String>,
    replacement: Option<String>,
) -> Result<(), std::io::Error> {
    REPLACED_COUNT.store(0, Ordering::SeqCst);
    FILE_COUNT.store(0, Ordering::SeqCst);
    TOTAL_LINES.store(0, Ordering::SeqCst);

    let files_names = get_files_names().await;

    for file_name in files_names.clone().iter() {
        //
    }

    let resume = match (search, replacement) {
        (Some(_), Some(_)) => format!(
            " {} changes in {} files: ",
            FILE_COUNT.load(Ordering::SeqCst),
            files_names.len()
        ),
        (Some(_), None) => format!(
            " {} matches in {} files: ",
            FILE_COUNT.load(Ordering::SeqCst),
            files_names.len()
        ),
        _ => format!(" {} files found: ", files_names.len()),
    }
    .black()
    .on_green()
    .bold()
    .to_string();

    // display_files_tree(6, 0, files_names)?;

    print_at(0, 4, &resume)?;

    Ok(())
}


async fn redraw(user_query: &str) -> Result<(), std::io::Error> {
    print_help()?;
    let split = split_query(user_query).await;
    split.print()?;
    display_results(split).await
}

async fn get_selected_file() -> Option<String> {
    get_key_value("selected_file").await
}

async fn set_selected_file(file: &str) {
    store_key_value("selected_file".to_string(), file.to_string()).await
}

async fn display_results(split: QuerySplit) -> Result<(), std::io::Error> {
    let glob = match &split.glob {
        Some(glob) => glob,
        None => return Ok(()),
    };
    let paths = store_glob_files(&split).await?;
    let first_file = paths.iter().find_map(|pb| {
        if pb.is_file() {
            if let Some(path) = pb.to_str() {
                return Some(path.to_string());
            }
            None
        } else {
            None
        }
    });
    if let Some(file) = first_file {
        set_selected_file(&file).await;
        display_selected_file().await?;
    }
    let files = list_glob_files(glob).await?;

    let files_paths = files
        .iter()
        .filter_map(|pb| match pb.to_str() {
            Some(path) => Some(path.to_string()),
            None => None,
        })
        .collect();
    display_files_tree(4, 0, files_paths).await?;
    Ok(())
}

async fn select_file_by(delta: isize) -> Result<(), std::io::Error> {
    let selected_file = get_selected_file().await;
    let files = get_files_names().await;
    let files = sorted_paths_from_tree(&tree_from_path_vec(files));
    let selected_index = files
        .iter()
        .position(|x| &Some(x.clone()) == &selected_file);

    let selected_index = match selected_index {
        Some(selected_index) => selected_index,
        None => return Ok(()),
    };

    let next_index = (selected_index as isize + delta) as usize;
    if next_index < files.len() {
        let next_file = &files[next_index];
        set_selected_file(next_file).await;
        display_tree().await?;
        display_selected_file().await?;
    }

    Ok(())
}

async fn display_tree() -> Result<(), std::io::Error> {
    let paths = get_files_names().await;
    display_files_tree(4, 0, paths).await
}

async fn display_selected_file() -> Result<(), std::io::Error> {
    let selected_file = get_selected_file().await;
    if let Some(selected_file) = selected_file {
        let content = match get_file(&selected_file).await {
            Some(content) => content,
            None => return Ok(()),
        };
        code_window(&selected_file, &content, 4).await?;
    }
    Ok(())
}

async fn code_window(path: &str, content: &str, top: usize) -> Result<(), std::io::Error> {
    let left = 40;
    let height = screen_height() - top;
    let width = screen_width() - left;

    let file_ext = match path.split('.').last() {
        Some(highlight) => Some(highlight.to_string()),
        None => None,
    };

    create_and_store_window(
        "result".to_string(),
        vec![
            WindowAttr::Title(Some(path.to_string())),
            WindowAttr::Content(content.lines().map(|x| x.to_string()).collect()),
            WindowAttr::Footer(None),
            WindowAttr::Top(top as usize),
            WindowAttr::Left(left as usize),
            WindowAttr::Width(width as usize),
            WindowAttr::Height(Some(height as usize)),
            WindowAttr::Decorated(true),
            WindowAttr::Scrollable(true),
            WindowAttr::Scroll(0),
            WindowAttr::Highlight(file_ext),
        ],
    )
    .await?
    .draw()
}

fn handle_key_event(event: crossterm::event::KeyEvent, user_query: &String) -> String {
    let mut user_query = user_query.clone();
    match event.kind {
        KeyEventKind::Press => {
            let input = event.code;
            match input {
                KeyCode::Char(c) => {
                    user_query.push(c);
                }
                KeyCode::Backspace => {
                    user_query.pop();
                }
                _ => (),
            }
        }
        _ => (),
    }
    user_query
}

async fn interactive_mode() -> Result<(), std::io::Error> {
    hide_cursor()?;
    execute!(stdout(), EnterAlternateScreen)?;
    execute!(stdout(), Clear(ClearType::All))?;
    get_screen_size()?;
    enable_raw_mode()?;
    let mut user_query = "**/*".to_string();
    handle_user_query_with_errors(&user_query).await;
    loop {
        if poll(Duration::from_millis(500))? {
            match read()? {
                Event::Key(event)
                    if [KeyCode::Esc].contains(&event.code)
                        || event.code == KeyCode::Char('c')
                            && event.modifiers == KeyModifiers::CONTROL =>
                {
                    disable_raw_mode()?;
                    execute!(stdout(), crossterm::terminal::LeaveAlternateScreen)?;
                    println!("Exiting...");
                    return Ok(());
                }
                Event::Key(event)
                    if event.code == KeyCode::Down && event.modifiers == KeyModifiers::CONTROL =>
                {
                    scroll_window("result", 5).await?;
                }
                Event::Key(event)
                    if event.code == KeyCode::Up && event.modifiers == KeyModifiers::CONTROL =>
                {
                    scroll_window("result", -5).await?;
                }
                Event::Key(event) if event.code == KeyCode::Up => {
                    select_file_by(-1).await?;
                }
                Event::Key(event) if event.code == KeyCode::Down => {
                    select_file_by(1).await?;
                }
                Event::Key(event) => {
                    user_query = handle_key_event(event, &user_query.clone());
                    handle_user_query_with_errors(&user_query).await;
                }
                Event::Resize(w, h) => {
                    set_screen_size(w as usize, h as usize);
                    redraw(&user_query).await?;
                }
                _ => (),
            }
        } else {
            // Timeout expired and no `Event` is available
        }
    }
}

async fn scroll_window(name: &str, offset: isize) -> Result<(), std::io::Error> {
    let mut window = match get_window(name).await {
        Some(window) => window,
        None => return Ok(()),
    };
    let scroll = window.scroll_by(offset)?;
    let _ = &scroll.draw()?;
    store_window(name.to_string(), window).await
}

#[tokio::main]
async fn main() -> Result<(), std::io::Error> {
    let opts: Opts = Opts::parse();

    if opts.classic {
        return classic_mode(&opts).await;
    }

    interactive_mode().await
}
